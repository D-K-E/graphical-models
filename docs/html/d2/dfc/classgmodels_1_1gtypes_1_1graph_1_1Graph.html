<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyGModels: gmodels.gtypes.graph.Graph Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PyGModels
   </div>
   <div id="projectbrief">Probabilistic Graphical Models by the book</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>gmodels</b></li><li class="navelem"><b>gtypes</b></li><li class="navelem"><b>graph</b></li><li class="navelem"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="../../da/db4/classgmodels_1_1gtypes_1_1graph_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gmodels.gtypes.graph.Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple finite graph \( G = (V, E) \) where \( V \) is the vertex set and \( E \) is the edge set.  
 <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for gmodels.gtypes.graph.Graph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.png" usemap="#gmodels.gtypes.graph.Graph_map" alt=""/>
  <map id="gmodels.gtypes.graph.Graph_map" name="gmodels.gtypes.graph.Graph_map">
<area href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html" alt="gmodels.gtypes.graphobj.GraphObject" shape="rect" coords="562,168,833,192"/>
<area href="../../d3/dc4/classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj.html" alt="gmodels.gtypes.abstractobj.AbstractGraphObj" shape="rect" coords="562,112,833,136"/>
<area href="../../d0/de3/classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractInfo.html" alt="gmodels.gtypes.abstractobj.AbstractInfo" shape="rect" coords="562,56,833,80"/>
<area href="../../dd/d00/classgmodels_1_1gtypes_1_1digraph_1_1DiGraph.html" title="Directed graph implementation." alt="gmodels.gtypes.digraph.DiGraph" shape="rect" coords="0,280,271,304"/>
<area href="../../d0/d1c/classgmodels_1_1gtypes_1_1path_1_1Path.html" title="path object as defined in Diestel 2017, p." alt="gmodels.gtypes.path.Path" shape="rect" coords="281,280,552,304"/>
<area href="../../d7/db3/classgmodels_1_1gtypes_1_1tree_1_1Tree.html" title="Ordered Tree object." alt="gmodels.gtypes.tree.Tree" shape="rect" coords="562,280,833,304"/>
<area href="../../d8/d73/classgmodels_1_1gtypes_1_1undigraph_1_1UndiGraph.html" title="Unidrected graph whose edges are of type Undirected." alt="gmodels.gtypes.undigraph.UndiGraph" shape="rect" coords="1124,280,1395,304"/>
<area href="../../df/da1/classgmodels_1_1pgmodel_1_1PGModel.html" alt="gmodels.pgmodel.PGModel" shape="rect" coords="1405,280,1676,304"/>
<area href="../../d2/d4f/classgmodels_1_1bayesian_1_1BayesianNetwork.html" title="bayesian network implementation" alt="gmodels.bayesian.BayesianNetwork" shape="rect" coords="0,336,271,360"/>
<area href="../../da/d1f/classgmodels_1_1gtypes_1_1path_1_1Cycle.html" title="Cycle as defined in Diestel p." alt="gmodels.gtypes.path.Cycle" shape="rect" coords="281,336,552,360"/>
<area href="../../d8/d43/classgmodels_1_1searchtree_1_1AndOrTree.html" title="And/Or search tree from pgmodel." alt="gmodels.searchtree.AndOrTree" shape="rect" coords="843,336,1114,360"/>
<area href="../../d9/d6b/classgmodels_1_1searchtree_1_1OrTree.html" title="Or search tree from pgmodel." alt="gmodels.searchtree.OrTree" shape="rect" coords="843,392,1114,416"/>
<area href="../../df/dd7/classgmodels_1_1markov_1_1MarkovNetwork.html" alt="gmodels.markov.MarkovNetwork" shape="rect" coords="1124,336,1395,360"/>
<area href="../../d2/d4f/classgmodels_1_1bayesian_1_1BayesianNetwork.html" title="bayesian network implementation" alt="gmodels.bayesian.BayesianNetwork" shape="rect" coords="1686,336,1957,360"/>
<area href="../../d1/da6/classgmodels_1_1lwfchain_1_1LWFChainGraph.html" title="LWF Chain graph model generalizing bayes networks and markov random fields." alt="gmodels.lwfchain.LWFChainGraph" shape="rect" coords="1686,392,1957,416"/>
<area href="../../df/dd7/classgmodels_1_1markov_1_1MarkovNetwork.html" alt="gmodels.markov.MarkovNetwork" shape="rect" coords="1686,448,1957,472"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a619405f96d213c996fab6e9c261e3180"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a619405f96d213c996fab6e9c261e3180">__init__</a> (self, str gid, data={}, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a14ea9c8ea2ee1f0dd204b21d42308783">nodes</a>=None, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa146aec295e76b05da4f247e4e4c5895">edges</a>=None)</td></tr>
<tr class="memdesc:a619405f96d213c996fab6e9c261e3180"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> Constructor.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a619405f96d213c996fab6e9c261e3180">More...</a><br /></td></tr>
<tr class="separator:a619405f96d213c996fab6e9c261e3180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a3fbfba7326849ce6d0dcc9fa46848"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a58a3fbfba7326849ce6d0dcc9fa46848">from_edgeset</a> (cls, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa146aec295e76b05da4f247e4e4c5895">edges</a>)</td></tr>
<tr class="memdesc:a58a3fbfba7326849ce6d0dcc9fa46848"><td class="mdescLeft">&#160;</td><td class="mdescRight">We construct the graph from given edge set using a random id.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a58a3fbfba7326849ce6d0dcc9fa46848">More...</a><br /></td></tr>
<tr class="separator:a58a3fbfba7326849ce6d0dcc9fa46848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d5a588faf693ce7d1af9a277a460f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a00d5a588faf693ce7d1af9a277a460f8">from_edge_node_set</a> (cls, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa146aec295e76b05da4f247e4e4c5895">edges</a>, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a14ea9c8ea2ee1f0dd204b21d42308783">nodes</a>)</td></tr>
<tr class="memdesc:a00d5a588faf693ce7d1af9a277a460f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">We construct the graph from given node, and edge sets using a random id.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a00d5a588faf693ce7d1af9a277a460f8">More...</a><br /></td></tr>
<tr class="separator:a00d5a588faf693ce7d1af9a277a460f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e394b4d834a0b4d6cc3fbd193a2eff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af5e394b4d834a0b4d6cc3fbd193a2eff">mk_nodes</a> (self, Optional[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]] ns, Optional[Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]] es)</td></tr>
<tr class="memdesc:af5e394b4d834a0b4d6cc3fbd193a2eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all nodes in a single set.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af5e394b4d834a0b4d6cc3fbd193a2eff">More...</a><br /></td></tr>
<tr class="separator:af5e394b4d834a0b4d6cc3fbd193a2eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995842afcea5e62b7fb96394a4b4c606"><td class="memItemLeft" align="right" valign="top">Dict[Tuple[str, str], int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a995842afcea5e62b7fb96394a4b4c606">to_adjmat</a> (self, vtype=int)</td></tr>
<tr class="memdesc:a995842afcea5e62b7fb96394a4b4c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform adjacency list to adjacency matrix representation.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a995842afcea5e62b7fb96394a4b4c606">More...</a><br /></td></tr>
<tr class="separator:a995842afcea5e62b7fb96394a4b4c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaffd49ffe08709f88da8eb947d1912f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#acaffd49ffe08709f88da8eb947d1912f">has_self_loop</a> (self)</td></tr>
<tr class="memdesc:acaffd49ffe08709f88da8eb947d1912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if graph has a self loop.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#acaffd49ffe08709f88da8eb947d1912f">More...</a><br /></td></tr>
<tr class="separator:acaffd49ffe08709f88da8eb947d1912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d0fc95e76ba3e1684901d07da832be"><td class="memItemLeft" align="right" valign="top">Dict[Tuple[str, str], bool]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ad0d0fc95e76ba3e1684901d07da832be">transitive_closure_matrix</a> (self)</td></tr>
<tr class="memdesc:ad0d0fc95e76ba3e1684901d07da832be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain transitive closure matrix of a given graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ad0d0fc95e76ba3e1684901d07da832be">More...</a><br /></td></tr>
<tr class="separator:ad0d0fc95e76ba3e1684901d07da832be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091c1c97613023c73a8e952a34a36dba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a091c1c97613023c73a8e952a34a36dba">mk_gdata</a> (self)</td></tr>
<tr class="memdesc:a091c1c97613023c73a8e952a34a36dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create edge list representation of graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a091c1c97613023c73a8e952a34a36dba">More...</a><br /></td></tr>
<tr class="separator:a091c1c97613023c73a8e952a34a36dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afd52aa1fb62820d2c2ffe2ef7a765d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a6afd52aa1fb62820d2c2ffe2ef7a765d">__eq__</a> (self, n)</td></tr>
<tr class="memdesc:a6afd52aa1fb62820d2c2ffe2ef7a765d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for equality.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a6afd52aa1fb62820d2c2ffe2ef7a765d">More...</a><br /></td></tr>
<tr class="separator:a6afd52aa1fb62820d2c2ffe2ef7a765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f5b35c8807312b39c649bb1896a9ff"><td class="memItemLeft" align="right" valign="top"><a id="a15f5b35c8807312b39c649bb1896a9ff"></a>
str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a15f5b35c8807312b39c649bb1896a9ff">__str__</a> (self)</td></tr>
<tr class="memdesc:a15f5b35c8807312b39c649bb1896a9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain string representation of the graph. <br /></td></tr>
<tr class="separator:a15f5b35c8807312b39c649bb1896a9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dffd094b7265d2de9ada8fe01357568"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5dffd094b7265d2de9ada8fe01357568">__hash__</a> (self)</td></tr>
<tr class="memdesc:a5dffd094b7265d2de9ada8fe01357568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hash value for the graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5dffd094b7265d2de9ada8fe01357568">More...</a><br /></td></tr>
<tr class="separator:a5dffd094b7265d2de9ada8fe01357568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a7bfb128185fbd175af7b2b96ca1dc"><td class="memItemLeft" align="right" valign="top">Dict[str, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa3a7bfb128185fbd175af7b2b96ca1dc">V</a> (self)</td></tr>
<tr class="memdesc:aa3a7bfb128185fbd175af7b2b96ca1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain vertices of the graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa3a7bfb128185fbd175af7b2b96ca1dc">More...</a><br /></td></tr>
<tr class="separator:aa3a7bfb128185fbd175af7b2b96ca1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd30c18d09e09fbdc18cc47d903aa5bc"><td class="memItemLeft" align="right" valign="top">Dict[str, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#abd30c18d09e09fbdc18cc47d903aa5bc">E</a> (self)</td></tr>
<tr class="memdesc:abd30c18d09e09fbdc18cc47d903aa5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edges of the graph  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#abd30c18d09e09fbdc18cc47d903aa5bc">More...</a><br /></td></tr>
<tr class="separator:abd30c18d09e09fbdc18cc47d903aa5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8626da05db0727085154c07ab16a913c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8626da05db0727085154c07ab16a913c">is_connected</a> (self)</td></tr>
<tr class="memdesc:a8626da05db0727085154c07ab16a913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if graph is connected If a graph has a single component, then we assume that it is connected graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8626da05db0727085154c07ab16a913c">More...</a><br /></td></tr>
<tr class="separator:a8626da05db0727085154c07ab16a913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8373887504460cfe5ffa3bcfef11ee78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8373887504460cfe5ffa3bcfef11ee78">is_adjacent_of</a> (cls, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e1, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e2)</td></tr>
<tr class="memdesc:a8373887504460cfe5ffa3bcfef11ee78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two edges are adjacent.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8373887504460cfe5ffa3bcfef11ee78">More...</a><br /></td></tr>
<tr class="separator:a8373887504460cfe5ffa3bcfef11ee78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c90f0b9ca76018de496f31f05ca67a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a16c90f0b9ca76018de496f31f05ca67a">is_node_incident</a> (cls, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a16c90f0b9ca76018de496f31f05ca67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a node is incident of an edge.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a16c90f0b9ca76018de496f31f05ca67a">More...</a><br /></td></tr>
<tr class="separator:a16c90f0b9ca76018de496f31f05ca67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca0965a51bd7e57467f990f8c3c394"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a05ca0965a51bd7e57467f990f8c3c394">is_related_to</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n2, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool] condition, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] es=None)</td></tr>
<tr class="memdesc:a05ca0965a51bd7e57467f990f8c3c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function for applying proximity conditions on a node pair.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a05ca0965a51bd7e57467f990f8c3c394">More...</a><br /></td></tr>
<tr class="separator:a05ca0965a51bd7e57467f990f8c3c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2985d817ab00400503592f373729c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#adbd2985d817ab00400503592f373729c">is_neighbour_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n2)</td></tr>
<tr class="memdesc:adbd2985d817ab00400503592f373729c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two nodes are neighbours We define the condition of neighborhood as having a common edge, not being the same  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#adbd2985d817ab00400503592f373729c">More...</a><br /></td></tr>
<tr class="separator:adbd2985d817ab00400503592f373729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5480b99977e709c077ee2fb49a004d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5480b99977e709c077ee2fb49a004d9b">is_node_independent_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n2)</td></tr>
<tr class="memdesc:a5480b99977e709c077ee2fb49a004d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two nodes are independent We consider two nodes independent if they are not the same, and they are not neighbours.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5480b99977e709c077ee2fb49a004d9b">More...</a><br /></td></tr>
<tr class="separator:a5480b99977e709c077ee2fb49a004d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9948757fcbea8280d1bc1a4744e12d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2c9948757fcbea8280d1bc1a4744e12d">is_stable</a> (self, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] ns)</td></tr>
<tr class="memdesc:a2c9948757fcbea8280d1bc1a4744e12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if given node set is stable  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2c9948757fcbea8280d1bc1a4744e12d">More...</a><br /></td></tr>
<tr class="separator:a2c9948757fcbea8280d1bc1a4744e12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7931cbb1cd0bc28a03ef114c3efbc9d"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa7931cbb1cd0bc28a03ef114c3efbc9d">neighbours_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1)</td></tr>
<tr class="memdesc:aa7931cbb1cd0bc28a03ef114c3efbc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain neighbour set of a given node.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa7931cbb1cd0bc28a03ef114c3efbc9d">More...</a><br /></td></tr>
<tr class="separator:aa7931cbb1cd0bc28a03ef114c3efbc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd022b8f1fb077dbc7b7dc9dc6974162"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#afd022b8f1fb077dbc7b7dc9dc6974162">nb_neighbours_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:afd022b8f1fb077dbc7b7dc9dc6974162"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain number of neighbours of a given node.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#afd022b8f1fb077dbc7b7dc9dc6974162">More...</a><br /></td></tr>
<tr class="separator:afd022b8f1fb077dbc7b7dc9dc6974162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519a91523a14681c92ba021746bb70f7"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a519a91523a14681c92ba021746bb70f7">edges_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:a519a91523a14681c92ba021746bb70f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the edge set of a given node.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a519a91523a14681c92ba021746bb70f7">More...</a><br /></td></tr>
<tr class="separator:a519a91523a14681c92ba021746bb70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c19d8a8716b563f8f6579c3678ac379"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8c19d8a8716b563f8f6579c3678ac379">outgoing_edges_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:a8c19d8a8716b563f8f6579c3678ac379"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the outgoing edge set of a given node.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8c19d8a8716b563f8f6579c3678ac379">More...</a><br /></td></tr>
<tr class="separator:a8c19d8a8716b563f8f6579c3678ac379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870136de71e0909de47bf1ecad90a912"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a870136de71e0909de47bf1ecad90a912">incoming_edges_of</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:a870136de71e0909de47bf1ecad90a912"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain incoming edges of a given graph  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a870136de71e0909de47bf1ecad90a912">More...</a><br /></td></tr>
<tr class="separator:a870136de71e0909de47bf1ecad90a912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214aff588f6a1d3d292aaa805588f76d"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a214aff588f6a1d3d292aaa805588f76d">edges_by_end</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:a214aff588f6a1d3d292aaa805588f76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge set of node.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a214aff588f6a1d3d292aaa805588f76d">More...</a><br /></td></tr>
<tr class="separator:a214aff588f6a1d3d292aaa805588f76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8604d28b17fa7c13acfce7a672cd7e94"><td class="memItemLeft" align="right" valign="top"><a id="a8604d28b17fa7c13acfce7a672cd7e94"></a>
Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8604d28b17fa7c13acfce7a672cd7e94">vertices</a> (self)</td></tr>
<tr class="memdesc:a8604d28b17fa7c13acfce7a672cd7e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain vertex set of the given graph <br /></td></tr>
<tr class="separator:a8604d28b17fa7c13acfce7a672cd7e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ea9c8ea2ee1f0dd204b21d42308783"><td class="memItemLeft" align="right" valign="top"><a id="a14ea9c8ea2ee1f0dd204b21d42308783"></a>
Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a14ea9c8ea2ee1f0dd204b21d42308783">nodes</a> (self)</td></tr>
<tr class="memdesc:a14ea9c8ea2ee1f0dd204b21d42308783"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain vertex set of the graph <br /></td></tr>
<tr class="separator:a14ea9c8ea2ee1f0dd204b21d42308783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa146aec295e76b05da4f247e4e4c5895"><td class="memItemLeft" align="right" valign="top"><a id="aa146aec295e76b05da4f247e4e4c5895"></a>
Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa146aec295e76b05da4f247e4e4c5895">edges</a> (self)</td></tr>
<tr class="memdesc:aa146aec295e76b05da4f247e4e4c5895"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge set of the graph <br /></td></tr>
<tr class="separator:aa146aec295e76b05da4f247e4e4c5895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925bcc74851c9a900383332a86e9cb5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a925bcc74851c9a900383332a86e9cb5f">is_in</a> (self, Union[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] ne)</td></tr>
<tr class="memdesc:a925bcc74851c9a900383332a86e9cb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if given edge or node is in graph  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a925bcc74851c9a900383332a86e9cb5f">More...</a><br /></td></tr>
<tr class="separator:a925bcc74851c9a900383332a86e9cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ac2968860a4d55c0f45f328dd43ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a1c7ac2968860a4d55c0f45f328dd43ed">order</a> (self)</td></tr>
<tr class="memdesc:a1c7ac2968860a4d55c0f45f328dd43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the number of vertices in the graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a1c7ac2968860a4d55c0f45f328dd43ed">More...</a><br /></td></tr>
<tr class="separator:a1c7ac2968860a4d55c0f45f328dd43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ad6e200e8efac7a5d420e14b6952a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab8ad6e200e8efac7a5d420e14b6952a9">nb_edges</a> (self)</td></tr>
<tr class="memdesc:ab8ad6e200e8efac7a5d420e14b6952a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain number of edges in the graph It corresponds to \( ||G|| \).  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab8ad6e200e8efac7a5d420e14b6952a9">More...</a><br /></td></tr>
<tr class="separator:ab8ad6e200e8efac7a5d420e14b6952a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0534a9c6c82464cc40a89608398a921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af0534a9c6c82464cc40a89608398a921">is_trivial</a> (self)</td></tr>
<tr class="memdesc:af0534a9c6c82464cc40a89608398a921"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if graph is trivial.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af0534a9c6c82464cc40a89608398a921">More...</a><br /></td></tr>
<tr class="separator:af0534a9c6c82464cc40a89608398a921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28faa97a14c1b297054dff59aea4be03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a28faa97a14c1b297054dff59aea4be03">vertex_by_id</a> (self, str node_id)</td></tr>
<tr class="memdesc:a28faa97a14c1b297054dff59aea4be03"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain vertex by using its identifier  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a28faa97a14c1b297054dff59aea4be03">More...</a><br /></td></tr>
<tr class="separator:a28faa97a14c1b297054dff59aea4be03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f39db59c44ceeb7b194892d395c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a058f39db59c44ceeb7b194892d395c26">edge_by_id</a> (self, str edge_id)</td></tr>
<tr class="memdesc:a058f39db59c44ceeb7b194892d395c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge by using its identifier  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a058f39db59c44ceeb7b194892d395c26">More...</a><br /></td></tr>
<tr class="separator:a058f39db59c44ceeb7b194892d395c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dedf24b0294f2167d82a66e1df687a"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a87dedf24b0294f2167d82a66e1df687a">edge_by_vertices</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> start, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> end)</td></tr>
<tr class="memdesc:a87dedf24b0294f2167d82a66e1df687a"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge set by using its vertices.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a87dedf24b0294f2167d82a66e1df687a">More...</a><br /></td></tr>
<tr class="separator:a87dedf24b0294f2167d82a66e1df687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6626c5feebb7366b90776e47effef10"><td class="memItemLeft" align="right" valign="top">Tuple[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ae6626c5feebb7366b90776e47effef10">vertices_of</a> (self, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ae6626c5feebb7366b90776e47effef10"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain all vertices associated with an edge.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ae6626c5feebb7366b90776e47effef10">More...</a><br /></td></tr>
<tr class="separator:ae6626c5feebb7366b90776e47effef10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d8b99fc125cad2935bb3d1723a1de0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a41d8b99fc125cad2935bb3d1723a1de0">is_homomorphism</a> (self, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] phi_map=lambda x:x, Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] psi_map=lambda x:x)</td></tr>
<tr class="memdesc:a41d8b99fc125cad2935bb3d1723a1de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a function is a homomorphism on the given graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a41d8b99fc125cad2935bb3d1723a1de0">More...</a><br /></td></tr>
<tr class="separator:a41d8b99fc125cad2935bb3d1723a1de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2857eff8ce47bd5c5b3326ee67806d1"><td class="memItemLeft" align="right" valign="top">Optional[Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af2857eff8ce47bd5c5b3326ee67806d1">set_op</a> (self, Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] obj, Callable[[Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]], Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool]] op)</td></tr>
<tr class="memdesc:af2857eff8ce47bd5c5b3326ee67806d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic set operation for graph  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af2857eff8ce47bd5c5b3326ee67806d1">More...</a><br /></td></tr>
<tr class="separator:af2857eff8ce47bd5c5b3326ee67806d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b824ee4a48a35d16e43107127b59af0"><td class="memItemLeft" align="right" valign="top"><a id="a0b824ee4a48a35d16e43107127b59af0"></a>
Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0b824ee4a48a35d16e43107127b59af0">intersection</a> (self, Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] aset)</td></tr>
<tr class="memdesc:a0b824ee4a48a35d16e43107127b59af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain intersection of either node or edge set <br /></td></tr>
<tr class="separator:a0b824ee4a48a35d16e43107127b59af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee3e394b96067bec663d665f7438ae8"><td class="memItemLeft" align="right" valign="top"><a id="a2ee3e394b96067bec663d665f7438ae8"></a>
Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2ee3e394b96067bec663d665f7438ae8">union</a> (self, Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] aset)</td></tr>
<tr class="memdesc:a2ee3e394b96067bec663d665f7438ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain union of either node or edge set <br /></td></tr>
<tr class="separator:a2ee3e394b96067bec663d665f7438ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4cb4857bd981019d5d1cea3c9b037"><td class="memItemLeft" align="right" valign="top"><a id="a51f4cb4857bd981019d5d1cea3c9b037"></a>
Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a51f4cb4857bd981019d5d1cea3c9b037">difference</a> (self, Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] aset)</td></tr>
<tr class="memdesc:a51f4cb4857bd981019d5d1cea3c9b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain set difference of either node or edge set <br /></td></tr>
<tr class="separator:a51f4cb4857bd981019d5d1cea3c9b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b11b4778a444762f16727389518f21f"><td class="memItemLeft" align="right" valign="top"><a id="a0b11b4778a444762f16727389518f21f"></a>
Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0b11b4778a444762f16727389518f21f">symmetric_difference</a> (self, Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] aset)</td></tr>
<tr class="memdesc:a0b11b4778a444762f16727389518f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain symmetric set difference of either node or edge set. <br /></td></tr>
<tr class="separator:a0b11b4778a444762f16727389518f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4667c305ab8ca54c607f71f8555c6ae0"><td class="memItemLeft" align="right" valign="top"><a id="a4667c305ab8ca54c607f71f8555c6ae0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a4667c305ab8ca54c607f71f8555c6ae0">contains</a> (self, Union[Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] a)</td></tr>
<tr class="memdesc:a4667c305ab8ca54c607f71f8555c6ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if argument set of nodes or edges is contained by graph <br /></td></tr>
<tr class="separator:a4667c305ab8ca54c607f71f8555c6ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094f7fe4997f16569078cae3dbc343f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a9094f7fe4997f16569078cae3dbc343f">graph_intersection</a> (self, gs)</td></tr>
<tr class="memdesc:a9094f7fe4997f16569078cae3dbc343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersection operation adapted for graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a9094f7fe4997f16569078cae3dbc343f">More...</a><br /></td></tr>
<tr class="separator:a9094f7fe4997f16569078cae3dbc343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d37d19a075cbc10b98fb44040fdf522"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5d37d19a075cbc10b98fb44040fdf522">graph_union</a> (self, gs)</td></tr>
<tr class="memdesc:a5d37d19a075cbc10b98fb44040fdf522"><td class="mdescLeft">&#160;</td><td class="mdescRight">union operation adapted for graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5d37d19a075cbc10b98fb44040fdf522">More...</a><br /></td></tr>
<tr class="separator:a5d37d19a075cbc10b98fb44040fdf522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1764c901702b50f95c6bccf7c36177a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a1764c901702b50f95c6bccf7c36177a8">graph_difference</a> (self, gs)</td></tr>
<tr class="memdesc:a1764c901702b50f95c6bccf7c36177a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set difference operation adapted for graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a1764c901702b50f95c6bccf7c36177a8">More...</a><br /></td></tr>
<tr class="separator:a1764c901702b50f95c6bccf7c36177a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a454d00e16e09cf01c6573900484f"><td class="memItemLeft" align="right" valign="top"><a id="a672a454d00e16e09cf01c6573900484f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a672a454d00e16e09cf01c6573900484f">graph_symmetric_difference</a> (self, gs)</td></tr>
<tr class="memdesc:a672a454d00e16e09cf01c6573900484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetric set difference operation adapted for graph. <br /></td></tr>
<tr class="separator:a672a454d00e16e09cf01c6573900484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd5f3a50bd93b90bfbc901444bf48a7"><td class="memItemLeft" align="right" valign="top"><a id="adfd5f3a50bd93b90bfbc901444bf48a7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#adfd5f3a50bd93b90bfbc901444bf48a7">subtract_node_from_self</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:adfd5f3a50bd93b90bfbc901444bf48a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract given node from the graph instance <br /></td></tr>
<tr class="separator:adfd5f3a50bd93b90bfbc901444bf48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239077400d675d6d144b9b53795104d"><td class="memItemLeft" align="right" valign="top"><a id="af239077400d675d6d144b9b53795104d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af239077400d675d6d144b9b53795104d">subtract_node</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n)</td></tr>
<tr class="memdesc:af239077400d675d6d144b9b53795104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new graph by subtracting the argument node. <br /></td></tr>
<tr class="separator:af239077400d675d6d144b9b53795104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab274cfb2fdc0158c2023bde1be712ff1"><td class="memItemLeft" align="right" valign="top"><a id="ab274cfb2fdc0158c2023bde1be712ff1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab274cfb2fdc0158c2023bde1be712ff1">subtract_nodes_from_self</a> (self, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] ns)</td></tr>
<tr class="memdesc:ab274cfb2fdc0158c2023bde1be712ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract the set of nodes from graph instance <br /></td></tr>
<tr class="separator:ab274cfb2fdc0158c2023bde1be712ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d8559aa5cb59716711e024dde56553"><td class="memItemLeft" align="right" valign="top"><a id="ac1d8559aa5cb59716711e024dde56553"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ac1d8559aa5cb59716711e024dde56553">subtract_nodes</a> (self, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] ns)</td></tr>
<tr class="memdesc:ac1d8559aa5cb59716711e024dde56553"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new graph by subtracting given set of nodes from graph instance <br /></td></tr>
<tr class="separator:ac1d8559aa5cb59716711e024dde56553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b72be29e5d89b6ad7ae1665d58b4a1"><td class="memItemLeft" align="right" valign="top"><a id="a35b72be29e5d89b6ad7ae1665d58b4a1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a35b72be29e5d89b6ad7ae1665d58b4a1">subtract_edge_from_self</a> (self, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a35b72be29e5d89b6ad7ae1665d58b4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract edge from edge set of graph instance <br /></td></tr>
<tr class="separator:a35b72be29e5d89b6ad7ae1665d58b4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea310a1d18601f7a1653af67de5b2fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aea310a1d18601f7a1653af67de5b2fd3">subtract_edge</a> (self, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:aea310a1d18601f7a1653af67de5b2fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new graph by subtracting edge from edge set of graph instance  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aea310a1d18601f7a1653af67de5b2fd3">More...</a><br /></td></tr>
<tr class="separator:aea310a1d18601f7a1653af67de5b2fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab913fe85e73eb4bd60863d7791935981"><td class="memItemLeft" align="right" valign="top"><a id="ab913fe85e73eb4bd60863d7791935981"></a>
<a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab913fe85e73eb4bd60863d7791935981">subtract_edge_with_nodes</a> (self, e)</td></tr>
<tr class="memdesc:ab913fe85e73eb4bd60863d7791935981"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract edge and remove its nodes as well. <br /></td></tr>
<tr class="separator:ab913fe85e73eb4bd60863d7791935981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c4a0b437491f79dc7b2eb65a284a47"><td class="memItemLeft" align="right" valign="top"><a id="a43c4a0b437491f79dc7b2eb65a284a47"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a43c4a0b437491f79dc7b2eb65a284a47">subtract</a> (self, Union[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] a)</td></tr>
<tr class="memdesc:a43c4a0b437491f79dc7b2eb65a284a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic subtraction operation. <br /></td></tr>
<tr class="separator:a43c4a0b437491f79dc7b2eb65a284a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e727547c7a5d9edd01cea57b3e9d8b"><td class="memItemLeft" align="right" valign="top"><a id="ae2e727547c7a5d9edd01cea57b3e9d8b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ae2e727547c7a5d9edd01cea57b3e9d8b">subtract_edges_from_self</a> (self, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] es)</td></tr>
<tr class="memdesc:ae2e727547c7a5d9edd01cea57b3e9d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract edge set from graph instance <br /></td></tr>
<tr class="separator:ae2e727547c7a5d9edd01cea57b3e9d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac34e2132232fa309ab4fd3b662b58d5"><td class="memItemLeft" align="right" valign="top"><a id="aac34e2132232fa309ab4fd3b662b58d5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aac34e2132232fa309ab4fd3b662b58d5">subtract_edges</a> (self, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] es)</td></tr>
<tr class="memdesc:aac34e2132232fa309ab4fd3b662b58d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new graph by subtracting edge set from graph instance <br /></td></tr>
<tr class="separator:aac34e2132232fa309ab4fd3b662b58d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3fdc737d911d95ea44d266e4af67d1"><td class="memItemLeft" align="right" valign="top"><a id="a2f3fdc737d911d95ea44d266e4af67d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2f3fdc737d911d95ea44d266e4af67d1">added_edge_between_if_none</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n2)</td></tr>
<tr class="memdesc:a2f3fdc737d911d95ea44d266e4af67d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges between nodes if there are no edges in between. <br /></td></tr>
<tr class="separator:a2f3fdc737d911d95ea44d266e4af67d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4072f10473224aebd3856f43c05c04c9"><td class="memItemLeft" align="right" valign="top"><a id="a4072f10473224aebd3856f43c05c04c9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_edge_to_self</b> (self, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="separator:a4072f10473224aebd3856f43c05c04c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3785464d594438a11f4bf17572a61fce"><td class="memItemLeft" align="right" valign="top"><a id="a3785464d594438a11f4bf17572a61fce"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_edge</b> (self, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> e)</td></tr>
<tr class="separator:a3785464d594438a11f4bf17572a61fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0010822ad7f3a72c6417821bf73e8ccc"><td class="memItemLeft" align="right" valign="top"><a id="a0010822ad7f3a72c6417821bf73e8ccc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_edges_to_self</b> (self, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] es)</td></tr>
<tr class="separator:a0010822ad7f3a72c6417821bf73e8ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8a993a2a4fcb0251e35b41dca3bfa6"><td class="memItemLeft" align="right" valign="top"><a id="adc8a993a2a4fcb0251e35b41dca3bfa6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_edges</b> (self, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] es)</td></tr>
<tr class="separator:adc8a993a2a4fcb0251e35b41dca3bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab135cafa9ca3e548439e55d598a18f67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab135cafa9ca3e548439e55d598a18f67">comp_degree</a> (self, Callable[[int, int], bool] fn, int comp_val)</td></tr>
<tr class="memdesc:ab135cafa9ca3e548439e55d598a18f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic comparison function for degree related operations  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ab135cafa9ca3e548439e55d598a18f67">More...</a><br /></td></tr>
<tr class="separator:ab135cafa9ca3e548439e55d598a18f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444a9b38facd99d758322f2f523b9d84"><td class="memItemLeft" align="right" valign="top"><a id="a444a9b38facd99d758322f2f523b9d84"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a444a9b38facd99d758322f2f523b9d84">max_degree</a> (self)</td></tr>
<tr class="memdesc:a444a9b38facd99d758322f2f523b9d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain maximum degree of the graph instance <br /></td></tr>
<tr class="separator:a444a9b38facd99d758322f2f523b9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed9fdce9f7df3b82858ab60f95232e"><td class="memItemLeft" align="right" valign="top"><a id="a7eed9fdce9f7df3b82858ab60f95232e"></a>
Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a7eed9fdce9f7df3b82858ab60f95232e">max_degree_vs</a> (self)</td></tr>
<tr class="memdesc:a7eed9fdce9f7df3b82858ab60f95232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain vertex set of whose degrees are equal to maximum degree. <br /></td></tr>
<tr class="separator:a7eed9fdce9f7df3b82858ab60f95232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c050f90bbd3f929d40e664f57e6008"><td class="memItemLeft" align="right" valign="top"><a id="a02c050f90bbd3f929d40e664f57e6008"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a02c050f90bbd3f929d40e664f57e6008">min_degree</a> (self)</td></tr>
<tr class="memdesc:a02c050f90bbd3f929d40e664f57e6008"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain minimum degree of graph instance <br /></td></tr>
<tr class="separator:a02c050f90bbd3f929d40e664f57e6008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe039c572df19ecf43bbf6bec5d1fac6"><td class="memItemLeft" align="right" valign="top"><a id="abe039c572df19ecf43bbf6bec5d1fac6"></a>
Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#abe039c572df19ecf43bbf6bec5d1fac6">min_degree_vs</a> (self)</td></tr>
<tr class="memdesc:abe039c572df19ecf43bbf6bec5d1fac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain set of vertices whose degree equal to minimum degree of graph instance <br /></td></tr>
<tr class="separator:abe039c572df19ecf43bbf6bec5d1fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2148af5e299b6af104fea2a8a99b587"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ad2148af5e299b6af104fea2a8a99b587">average_degree</a> (self)</td></tr>
<tr class="memdesc:ad2148af5e299b6af104fea2a8a99b587"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the average degree of graph instance  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ad2148af5e299b6af104fea2a8a99b587">More...</a><br /></td></tr>
<tr class="separator:ad2148af5e299b6af104fea2a8a99b587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b89e59f8615ad472bee382b530cd894"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2b89e59f8615ad472bee382b530cd894">edge_vertex_ratio</a> (self)</td></tr>
<tr class="memdesc:a2b89e59f8615ad472bee382b530cd894"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge vertex ratio of graph instance Corresponds to  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2b89e59f8615ad472bee382b530cd894">More...</a><br /></td></tr>
<tr class="separator:a2b89e59f8615ad472bee382b530cd894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d447c5d64a7b522283048ed416b8c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a84d447c5d64a7b522283048ed416b8c2">ev_ratio_from_average_degree</a> (self, float <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ad2148af5e299b6af104fea2a8a99b587">average_degree</a>)</td></tr>
<tr class="memdesc:a84d447c5d64a7b522283048ed416b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain edge vertex ratio from average degree  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a84d447c5d64a7b522283048ed416b8c2">More...</a><br /></td></tr>
<tr class="separator:a84d447c5d64a7b522283048ed416b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5af7f2f050042080425fb39f9b22f6"><td class="memItemLeft" align="right" valign="top"><a id="a7c5af7f2f050042080425fb39f9b22f6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a7c5af7f2f050042080425fb39f9b22f6">ev_ratio</a> (self)</td></tr>
<tr class="memdesc:a7c5af7f2f050042080425fb39f9b22f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorthand for <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a84d447c5d64a7b522283048ed416b8c2" title="obtain edge vertex ratio from average degree">ev_ratio_from_average_degree()</a> <br /></td></tr>
<tr class="separator:a7c5af7f2f050042080425fb39f9b22f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce9cb8cf0951f366f6a012c8c859a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa8ce9cb8cf0951f366f6a012c8c859a0">visit_graph_dfs</a> (self, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]] edge_generator, bool check_cycle=False)</td></tr>
<tr class="memdesc:aa8ce9cb8cf0951f366f6a012c8c859a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">interior visit function for depth first enumeration of graph instance.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa8ce9cb8cf0951f366f6a012c8c859a0">More...</a><br /></td></tr>
<tr class="separator:aa8ce9cb8cf0951f366f6a012c8c859a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7564c1b21abbaef27bb1809b473d0d"><td class="memItemLeft" align="right" valign="top"><a id="aee7564c1b21abbaef27bb1809b473d0d"></a>
Dict[str, Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aee7564c1b21abbaef27bb1809b473d0d">from_preds_to_edgeset</a> (self, Dict[str, Dict[str, str]] preds)</td></tr>
<tr class="memdesc:aee7564c1b21abbaef27bb1809b473d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the edge set implied by the predecessor array. <br /></td></tr>
<tr class="separator:aee7564c1b21abbaef27bb1809b473d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e8d39b5c3e805ff0a8f935963c95a"><td class="memItemLeft" align="right" valign="top">Optional[Tuple[str, str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0d0e8d39b5c3e805ff0a8f935963c95a">dfs_forest</a> (self, str u, Dict[str, str] pred, Dict[str, int] marked, Dict[str, int] d, Dict[str, int] f, Set[str] T, Dict[str, List[Dict[str, Union[str, int]]]] cycles, int time, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]] edge_generator, bool check_cycle=False)</td></tr>
<tr class="memdesc:a0d0e8d39b5c3e805ff0a8f935963c95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted for cycle detection dfs recursive forest from Erciyes 2018, Guide <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> ..., p.152 alg.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0d0e8d39b5c3e805ff0a8f935963c95a">More...</a><br /></td></tr>
<tr class="separator:a0d0e8d39b5c3e805ff0a8f935963c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e7d0083348977abb6329bc1ef323eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a60e7d0083348977abb6329bc1ef323eb">has_cycles</a> (self)</td></tr>
<tr class="memdesc:a60e7d0083348977abb6329bc1ef323eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if graph instance contains cycles.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a60e7d0083348977abb6329bc1ef323eb">More...</a><br /></td></tr>
<tr class="separator:a60e7d0083348977abb6329bc1ef323eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ed19ae0672276d1fba1fddda4f3273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a38ed19ae0672276d1fba1fddda4f3273">shortest_path_length</a> (self)</td></tr>
<tr class="memdesc:a38ed19ae0672276d1fba1fddda4f3273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the shortest possible path length for graph instance.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a38ed19ae0672276d1fba1fddda4f3273">More...</a><br /></td></tr>
<tr class="separator:a38ed19ae0672276d1fba1fddda4f3273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe28686daac19f3ac7e66d20ec36f1ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#afe28686daac19f3ac7e66d20ec36f1ac">shortest_cycle_length</a> (self)</td></tr>
<tr class="memdesc:afe28686daac19f3ac7e66d20ec36f1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the shortest possible cycle length for graph instance The interpretation comes from Diestel 2017, p.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#afe28686daac19f3ac7e66d20ec36f1ac">More...</a><br /></td></tr>
<tr class="separator:afe28686daac19f3ac7e66d20ec36f1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b90352b4987f8f5dd60185eae65be35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a4b90352b4987f8f5dd60185eae65be35">nb_components</a> (self)</td></tr>
<tr class="memdesc:a4b90352b4987f8f5dd60185eae65be35"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of connected components in the given graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a4b90352b4987f8f5dd60185eae65be35">More...</a><br /></td></tr>
<tr class="separator:a4b90352b4987f8f5dd60185eae65be35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1aa3ff68d6a096dfb3e6ac3efac98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5fc1aa3ff68d6a096dfb3e6ac3efac98">is_tree</a> (self)</td></tr>
<tr class="memdesc:a5fc1aa3ff68d6a096dfb3e6ac3efac98"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if graph instance is a tree.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a5fc1aa3ff68d6a096dfb3e6ac3efac98">More...</a><br /></td></tr>
<tr class="separator:a5fc1aa3ff68d6a096dfb3e6ac3efac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64eb3ae4710570467181679dcc7d819"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af64eb3ae4710570467181679dcc7d819">get_component_nodes</a> (self, str root_node_id)</td></tr>
<tr class="memdesc:af64eb3ae4710570467181679dcc7d819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get component nodes of a graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af64eb3ae4710570467181679dcc7d819">More...</a><br /></td></tr>
<tr class="separator:af64eb3ae4710570467181679dcc7d819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc61d72314c82508570dc331fe6530fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#abc61d72314c82508570dc331fe6530fc">get_component</a> (self, str root_node_id)</td></tr>
<tr class="memdesc:abc61d72314c82508570dc331fe6530fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a component graph from graph instance  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#abc61d72314c82508570dc331fe6530fc">More...</a><br /></td></tr>
<tr class="separator:abc61d72314c82508570dc331fe6530fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22537554ec4c1adef41e1f3f1aa566cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a22537554ec4c1adef41e1f3f1aa566cd">get_components</a> (self)</td></tr>
<tr class="memdesc:a22537554ec4c1adef41e1f3f1aa566cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get components of graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a22537554ec4c1adef41e1f3f1aa566cd">More...</a><br /></td></tr>
<tr class="separator:a22537554ec4c1adef41e1f3f1aa566cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99db900bb2a6858ec465c8ab593da17c"><td class="memItemLeft" align="right" valign="top">Set[FrozenSet[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a99db900bb2a6858ec465c8ab593da17c">get_components_as_node_sets</a> (self)</td></tr>
<tr class="memdesc:a99db900bb2a6858ec465c8ab593da17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain component as a set of node sets.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a99db900bb2a6858ec465c8ab593da17c">More...</a><br /></td></tr>
<tr class="separator:a99db900bb2a6858ec465c8ab593da17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74c332f60a68c658b05dd429c20a17f"><td class="memItemLeft" align="right" valign="top">Dict[str, Union[dict, set]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ae74c332f60a68c658b05dd429c20a17f">find_shortest_paths</a> (self, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> n1, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]] edge_generator)</td></tr>
<tr class="memdesc:ae74c332f60a68c658b05dd429c20a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">find shortest path from given node to all other nodes  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#ae74c332f60a68c658b05dd429c20a17f">More...</a><br /></td></tr>
<tr class="separator:ae74c332f60a68c658b05dd429c20a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801033810cdc3e12b3fd5f5709dce248"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a801033810cdc3e12b3fd5f5709dce248">find_articulation_points</a> (self, Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] graph_maker)</td></tr>
<tr class="memdesc:a801033810cdc3e12b3fd5f5709dce248"><td class="mdescLeft">&#160;</td><td class="mdescRight">find articulation points of graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a801033810cdc3e12b3fd5f5709dce248">More...</a><br /></td></tr>
<tr class="separator:a801033810cdc3e12b3fd5f5709dce248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d0431d19d2efbd11b169f91132f1ee"><td class="memItemLeft" align="right" valign="top">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a63d0431d19d2efbd11b169f91132f1ee">find_bridges</a> (self, Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] graph_maker)</td></tr>
<tr class="memdesc:a63d0431d19d2efbd11b169f91132f1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">find bridges of a given graph.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a63d0431d19d2efbd11b169f91132f1ee">More...</a><br /></td></tr>
<tr class="separator:a63d0431d19d2efbd11b169f91132f1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69915971f33a3a03ab0a00e303fbc8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a69915971f33a3a03ab0a00e303fbc8d2">get_subgraph_by_vertices</a> (self, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] vs, Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]], bool] edge_policy=lambda x, set([x.start(), x.end()]).issubset(ys) is True ys)</td></tr>
<tr class="memdesc:a69915971f33a3a03ab0a00e303fbc8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subgraph using vertices.  <a href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a69915971f33a3a03ab0a00e303fbc8d2">More...</a><br /></td></tr>
<tr class="separator:a69915971f33a3a03ab0a00e303fbc8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb99b081921482641b73d1ccd6da1990"><td class="memItemLeft" align="right" valign="top"><a id="afb99b081921482641b73d1ccd6da1990"></a>
<a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#afb99b081921482641b73d1ccd6da1990">__add__</a> (self, Union[Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>, <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] a)</td></tr>
<tr class="memdesc:afb99b081921482641b73d1ccd6da1990"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloads + sign for doing algebraic operations with graph objects. <br /></td></tr>
<tr class="separator:afb99b081921482641b73d1ccd6da1990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94629fce3ffff3e8eebc4e70a9eab3"><td class="memItemLeft" align="right" valign="top"><a id="a2e94629fce3ffff3e8eebc4e70a9eab3"></a>
<a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a2e94629fce3ffff3e8eebc4e70a9eab3">__sub__</a> (self, Union[Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>, <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>] a)</td></tr>
<tr class="memdesc:a2e94629fce3ffff3e8eebc4e70a9eab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloads - sign for doing algebraic operations with graph objects. <br /></td></tr>
<tr class="separator:a2e94629fce3ffff3e8eebc4e70a9eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">gmodels.gtypes.graphobj.GraphObject</a></td></tr>
<tr class="memitem:ac8ebbe2042b392205f667cafd1bc8cdf inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memItemLeft" align="right" valign="top"><a id="ac8ebbe2042b392205f667cafd1bc8cdf"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, str oid, odata={})</td></tr>
<tr class="separator:ac8ebbe2042b392205f667cafd1bc8cdf inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc1fb8fb6b2b539b78fd9a2b43805d7 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memItemLeft" align="right" valign="top"><a id="a5dc1fb8fb6b2b539b78fd9a2b43805d7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (self)</td></tr>
<tr class="separator:a5dc1fb8fb6b2b539b78fd9a2b43805d7 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fbff59db0ef14c53cefb7a6f652781 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memItemLeft" align="right" valign="top"><a id="a45fbff59db0ef14c53cefb7a6f652781"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>id</b> (self)</td></tr>
<tr class="separator:a45fbff59db0ef14c53cefb7a6f652781 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568f7a673f9cbcede7aa30ddde57ebea inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memItemLeft" align="right" valign="top"><a id="a568f7a673f9cbcede7aa30ddde57ebea"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>clear_data</b> (self)</td></tr>
<tr class="separator:a568f7a673f9cbcede7aa30ddde57ebea inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3101125ff35b95e13c85b31ae38d76 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memItemLeft" align="right" valign="top"><a id="a2e3101125ff35b95e13c85b31ae38d76"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>update_data</b> (self, dict ndata)</td></tr>
<tr class="separator:a2e3101125ff35b95e13c85b31ae38d76 inherit pub_methods_classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d3/dc4/classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj.html">gmodels.gtypes.abstractobj.AbstractGraphObj</a></td></tr>
<tr class="memitem:a65c4b516581bf98c7582af86dbba0375 inherit pub_methods_classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj"><td class="memItemLeft" align="right" valign="top"><a id="a65c4b516581bf98c7582af86dbba0375"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (self)</td></tr>
<tr class="separator:a65c4b516581bf98c7582af86dbba0375 inherit pub_methods_classgmodels_1_1gtypes_1_1abstractobj_1_1AbstractGraphObj"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad2d157d5bdefdf3e586bd290504d82ef"><td class="memItemLeft" align="right" valign="top"><a id="ad2d157d5bdefdf3e586bd290504d82ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b></td></tr>
<tr class="separator:ad2d157d5bdefdf3e586bd290504d82ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a659369ae5c1dce16aad9d0182e6c2"><td class="memItemLeft" align="right" valign="top"><a id="ac4a659369ae5c1dce16aad9d0182e6c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>props</b></td></tr>
<tr class="separator:ac4a659369ae5c1dce16aad9d0182e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple finite graph \( G = (V, E) \) where \( V \) is the vertex set and \( E \) is the edge set. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a619405f96d213c996fab6e9c261e3180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619405f96d213c996fab6e9c261e3180">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] &#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] &#160;</td>
          <td class="paramname"><em>edges</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gid</td><td>unique graph id. In most cases we generate a random id with uuid4</td></tr>
    <tr><td class="paramname">data</td><td>is any data associated with the graph.</td></tr>
    <tr><td class="paramname">nodes</td><td>a node/vertex set. </td></tr>
    <tr><td class="paramname">edges</td><td>an edge set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>If the graph is trivial, we raise a value error, as most algorithms don't work with trivial graphs.</td></tr>
  </table>
  </dd>
</dl>
<p>We construct the graph from given node and edge set. For quick look up we store them in hash tables. The gdata member also stores an edge list representation, in order to facilitate some of the basic look up functionality concerning neighbours of vertices.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; a = Node(<span class="stringliteral">&quot;a&quot;</span>, {})  <span class="comment"># b</span></div>
<div class="line">&gt;&gt;&gt; b = Node(<span class="stringliteral">&quot;b&quot;</span>, {})  <span class="comment"># c</span></div>
<div class="line">&gt;&gt;&gt; f = Node(<span class="stringliteral">&quot;f&quot;</span>, {})  <span class="comment"># d</span></div>
<div class="line">&gt;&gt;&gt; e = Node(<span class="stringliteral">&quot;e&quot;</span>, {})  <span class="comment"># e</span></div>
<div class="line">&gt;&gt;&gt; ab = Edge(</div>
<div class="line">&gt;&gt;&gt;    <span class="stringliteral">&quot;ab&quot;</span>, start_node=a, end_node=b, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; be = Edge(</div>
<div class="line">&gt;&gt;&gt;    <span class="stringliteral">&quot;be&quot;</span>, start_node=b, end_node=e, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;graph&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([a, b, e, f]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([ab, be]),</div>
<div class="line">&gt;&gt;&gt; )</div>
</div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="../../d8/d73/classgmodels_1_1gtypes_1_1undigraph_1_1UndiGraph.html#a4a63245f18c2341777ad7ee83e733925">gmodels.gtypes.undigraph.UndiGraph</a>, and <a class="el" href="../../dd/d00/classgmodels_1_1gtypes_1_1digraph_1_1DiGraph.html#a8f384e53641d72e7898ce5afc643ff2c">gmodels.gtypes.digraph.DiGraph</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6afd52aa1fb62820d2c2ffe2ef7a765d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afd52aa1fb62820d2c2ffe2ef7a765d">&#9670;&nbsp;</a></span>__eq__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for equality. </p>
<p>This is not a strict check for equality of graphs. We simply check for ids. There is nothing mathematical about it. Should not be used in the context of graph algebra. </p><div class="fragment"><div class="line">&gt;&gt;&gt; a = Node(<span class="stringliteral">&quot;a&quot;</span>, {})  <span class="comment"># a</span></div>
<div class="line">&gt;&gt;&gt; e = Node(<span class="stringliteral">&quot;e&quot;</span>, {})  <span class="comment"># e</span></div>
<div class="line">&gt;&gt;&gt; b = Node(<span class="stringliteral">&quot;b&quot;</span>, {})  <span class="comment"># e</span></div>
<div class="line">&gt;&gt;&gt; ae = Edge(</div>
<div class="line">&gt;&gt;&gt;    <span class="stringliteral">&quot;ae&quot;</span>, start_node=a, end_node=e, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; g1 = Graph(<span class="stringliteral">&quot;graph&quot;</span>, </div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([a, e]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([ae])</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; g2 = Graph(<span class="stringliteral">&quot;other&quot;</span>, </div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([a, e]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([ae])</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; g3 = Graph(<span class="stringliteral">&quot;graph&quot;</span>, </div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([a, e, b]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([ae])</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; g1 == g2</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">False</span></div>
<div class="line">&gt;&gt;&gt; g1 == g3</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5dffd094b7265d2de9ada8fe01357568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dffd094b7265d2de9ada8fe01357568">&#9670;&nbsp;</a></span>__hash__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.__hash__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hash value for the graph. </p>
<p>Since the identifiers of graphs are randomly generated in most cases, hashing them by their string representation should not create a problem, because the string representation contains the identifier of the graph. </p>

</div>
</div>
<a id="ad2148af5e299b6af104fea2a8a99b587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2148af5e299b6af104fea2a8a99b587">&#9670;&nbsp;</a></span>average_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float gmodels.gtypes.graph.Graph.average_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the average degree of graph instance </p>
<p>The average degree is calculated using the formula: </p><p class="formulaDsp">
\[ d(G) = \frac{1}{V[G]} \sum_{v \in V[G]} d(v) \]
</p>
<p>It can be found in Diestel 2017, p. 5 </p>

</div>
</div>
<a id="ab135cafa9ca3e548439e55d598a18f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab135cafa9ca3e548439e55d598a18f67">&#9670;&nbsp;</a></span>comp_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.comp_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[int, int], bool]&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic comparison function for degree related operations </p>
<p>It is used in the context of finding maximum or minimum degree of the graph instance. </p>

</div>
</div>
<a id="a0d0e8d39b5c3e805ff0a8f935963c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0e8d39b5c3e805ff0a8f935963c95a">&#9670;&nbsp;</a></span>dfs_forest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Tuple[str, str]] gmodels.gtypes.graph.Graph.dfs_forest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, str]&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, int]&#160;</td>
          <td class="paramname"><em>marked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, int]&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, int]&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[str]&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, List[Dict[str, Union[str, int]]]]&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]&#160;</td>
          <td class="paramname"><em>edge_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>check_cycle</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted for cycle detection dfs recursive forest from Erciyes 2018, Guide <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> ..., p.152 alg. </p>
<p>6.7</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>storing last visit times per node </td></tr>
    <tr><td class="paramname">d</td><td>storing first visit times per node </td></tr>
    <tr><td class="paramname">cycles</td><td>storing cycle info </td></tr>
    <tr><td class="paramname">marked</td><td>storing if node is visited </td></tr>
    <tr><td class="paramname">pred</td><td>storing the parent of nodes </td></tr>
    <tr><td class="paramname">g</td><td>graph we are searching for </td></tr>
    <tr><td class="paramname">u</td><td>node id </td></tr>
    <tr><td class="paramname">T</td><td>set of pred nodes </td></tr>
    <tr><td class="paramname">time</td><td>global visit counter </td></tr>
    <tr><td class="paramname">check_cycle</td><td>fill cycles if it is detected </td></tr>
    <tr><td class="paramname">edge_generator</td><td>generate edges of a vertex with respect to graph type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd30c18d09e09fbdc18cc47d903aa5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd30c18d09e09fbdc18cc47d903aa5bc">&#9670;&nbsp;</a></span>E()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.E </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edges of the graph </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if edge set is empty for the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058f39db59c44ceeb7b194892d395c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f39db59c44ceeb7b194892d395c26">&#9670;&nbsp;</a></span>edge_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a> gmodels.gtypes.graph.Graph.edge_by_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>edge_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edge by using its identifier </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if the edge id is not in graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87dedf24b0294f2167d82a66e1df687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dedf24b0294f2167d82a66e1df687a">&#9670;&nbsp;</a></span>edge_by_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.edge_by_vertices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edge set by using its vertices. </p>
<p>We take all edges that consist of given two nodes</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if any of argument nodes are not inside the graph. </td></tr>
    <tr><td class="paramname">ValueError</td><td>if there are no edges that consist of argument nodes. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="../../dd/d00/classgmodels_1_1gtypes_1_1digraph_1_1DiGraph.html#a2e4f8ac4d768c12545cc6fe367caa06b">gmodels.gtypes.digraph.DiGraph</a>.</p>

</div>
</div>
<a id="a2b89e59f8615ad472bee382b530cd894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b89e59f8615ad472bee382b530cd894">&#9670;&nbsp;</a></span>edge_vertex_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float gmodels.gtypes.graph.Graph.edge_vertex_ratio </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edge vertex ratio of graph instance Corresponds to </p>
<p class="formulaDsp">
\[\epsilon(G)\]
</p>
<p>. The formula comes from Diestel 2017, p. 5. </p>

</div>
</div>
<a id="a214aff588f6a1d3d292aaa805588f76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214aff588f6a1d3d292aaa805588f76d">&#9670;&nbsp;</a></span>edges_by_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.edges_by_end </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edge set of node. </p>
<p>This function should not be confused with <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a870136de71e0909de47bf1ecad90a912" title="obtain incoming edges of a given graph">incoming_edges_of()</a> or <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8c19d8a8716b563f8f6579c3678ac379" title="obtain the outgoing edge set of a given node.">outgoing_edges_of()</a> functions. This function provides the edge set of the given node considering the type of the edge as well.</p>
<p>If the edge is undirected, it is going to be included in the set if the node is an endvertex of it. If the edge is directed, it is going to be included in the set if the node is at the end position of the vertex. </p>

</div>
</div>
<a id="a519a91523a14681c92ba021746bb70f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519a91523a14681c92ba021746bb70f7">&#9670;&nbsp;</a></span>edges_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.edges_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the edge set of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node whose adjacent edges we are interested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge set of node.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if node is not in graph we raise a value error</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;g1&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([e1, e2]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; edges = graph.edges_of(n2)</div>
<div class="line">&gt;&gt;&gt; edges == set([e1, e2])</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84d447c5d64a7b522283048ed416b8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d447c5d64a7b522283048ed416b8c2">&#9670;&nbsp;</a></span>ev_ratio_from_average_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.ev_ratio_from_average_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>average_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain edge vertex ratio from average degree </p>
<p>Applies the following formula: </p><p class="formulaDsp">
\[ |E[G]| = \frac{1}{2} \sum_{v \in V[G]} d(v) = 1/2 * d(G) * |V[G]| \]
</p>
<p> It comes from Diestel 2017, p. 5 </p>

</div>
</div>
<a id="a801033810cdc3e12b3fd5f5709dce248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801033810cdc3e12b3fd5f5709dce248">&#9670;&nbsp;</a></span>find_articulation_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] gmodels.gtypes.graph.Graph.find_articulation_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]
    &#160;</td>
          <td class="paramname"><em>graph_maker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find articulation points of graph. </p>
<p>Find the articulation points of a graph. An articulation point, also called cut vertex is defined as the vertex that separates two other vertices of the same component.</p>
<p>The algorithm we implement here is the naive version see, Erciyes 2018, p. 228. For the definition of the cut vertex, see Diestel 2017, p. 11 </p>

</div>
</div>
<a id="a63d0431d19d2efbd11b169f91132f1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d0431d19d2efbd11b169f91132f1ee">&#9670;&nbsp;</a></span>find_bridges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.find_bridges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td>
          <td class="paramname"><em>graph_maker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find bridges of a given graph. </p>
<p>A bridge is defined as the edge that separates its ends in the same component. The algorithm we implement here is the naive version provided by Erciyes 2018, p. 228. For the definition of the bridge, see Diestel 2017, p. 11 </p>

</div>
</div>
<a id="ae74c332f60a68c658b05dd429c20a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74c332f60a68c658b05dd429c20a17f">&#9670;&nbsp;</a></span>find_shortest_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Union[dict, set]] gmodels.gtypes.graph.Graph.find_shortest_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]
    &#160;</td>
          <td class="paramname"><em>edge_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find shortest path from given node to all other nodes </p>
<p>Applies the Breadth first search algorithm from Even and Guy Even 2012, p. 12</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if given node is not found in graph instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00d5a588faf693ce7d1af9a277a460f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d5a588faf693ce7d1af9a277a460f8">&#9670;&nbsp;</a></span>from_edge_node_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.from_edge_node_set </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We construct the graph from given node, and edge sets using a random id. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> for more information</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>set of edges </td></tr>
    <tr><td class="paramname">nodes</td><td>set of nodes</td></tr>
  </table>
  </dd>
</dl>
<p>We iterate over set of edges and add the nodes that are not inside the node set. We pass both parameters to <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> constructor afterwards. </p>

</div>
</div>
<a id="a58a3fbfba7326849ce6d0dcc9fa46848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a3fbfba7326849ce6d0dcc9fa46848">&#9670;&nbsp;</a></span>from_edgeset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.from_edgeset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We construct the graph from given edge set using a random id. </p>
<p>See </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> for more information</dd></dl>
<p>We obtain nodes from edges then pass them to graph constructor. </p>

<p>Reimplemented in <a class="el" href="../../d7/db3/classgmodels_1_1gtypes_1_1tree_1_1Tree.html#a8414ba13d097591a7e41ceb254916dbe">gmodels.gtypes.tree.Tree</a>.</p>

</div>
</div>
<a id="abc61d72314c82508570dc331fe6530fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc61d72314c82508570dc331fe6530fc">&#9670;&nbsp;</a></span>get_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a> gmodels.gtypes.graph.Graph.get_component </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>root_node_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a component graph from graph instance </p>
<p>As subgraphs are also graphs, components are in the strict sense a graph. </p>

</div>
</div>
<a id="af64eb3ae4710570467181679dcc7d819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64eb3ae4710570467181679dcc7d819">&#9670;&nbsp;</a></span>get_component_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] gmodels.gtypes.graph.Graph.get_component_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>root_node_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get component nodes of a graph. </p>
<p>Given a root node id for a component, obtain its node set. </p>

</div>
</div>
<a id="a22537554ec4c1adef41e1f3f1aa566cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22537554ec4c1adef41e1f3f1aa566cd">&#9670;&nbsp;</a></span>get_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.get_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get components of graph. </p>
<p>Each component is provided as a graph </p>

</div>
</div>
<a id="a99db900bb2a6858ec465c8ab593da17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99db900bb2a6858ec465c8ab593da17c">&#9670;&nbsp;</a></span>get_components_as_node_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[FrozenSet[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]] gmodels.gtypes.graph.Graph.get_components_as_node_sets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain component as a set of node sets. </p>
<p>The node set members of the returning set are of type frozenset due to set being an unhashable type in python. </p>

</div>
</div>
<a id="a69915971f33a3a03ab0a00e303fbc8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69915971f33a3a03ab0a00e303fbc8d2">&#9670;&nbsp;</a></span>get_subgraph_by_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a> gmodels.gtypes.graph.Graph.get_subgraph_by_vertices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>, Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]], bool] &#160;</td>
          <td class="paramname"><em>edge_policy</em> = <code>lambda&#160;x</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set(
            [x.start(), x.end()]
        ).issubset(ys)
        is True&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subgraph using vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vs</td><td>set of vertices for the subgraph </td></tr>
    <tr><td class="paramname">edge_policy</td><td>determines which edges should be conserved. By default we conserve edges whose incident nodes are a subset of vs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1764c901702b50f95c6bccf7c36177a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1764c901702b50f95c6bccf7c36177a8">&#9670;&nbsp;</a></span>graph_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.graph_difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set difference operation adapted for graph. </p>
<p>Difference of graph with another is the graph resulting from set difference sets of their nodes and their edges. </p>

</div>
</div>
<a id="a9094f7fe4997f16569078cae3dbc343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9094f7fe4997f16569078cae3dbc343f">&#9670;&nbsp;</a></span>graph_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.graph_intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>intersection operation adapted for graph. </p>
<p>Intersection of graph with another is the graph resulting from intersection sets of their nodes and their edges. </p>

</div>
</div>
<a id="a5d37d19a075cbc10b98fb44040fdf522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d37d19a075cbc10b98fb44040fdf522">&#9670;&nbsp;</a></span>graph_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.graph_union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>union operation adapted for graph. </p>
<p>Union of graph with another is the graph resulting from union sets of their nodes and their edges. </p>

</div>
</div>
<a id="a60e7d0083348977abb6329bc1ef323eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e7d0083348977abb6329bc1ef323eb">&#9670;&nbsp;</a></span>has_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.has_cycles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if graph instance contains cycles. </p>
<p>This interpretation is from Diestel 2017, p. 8. The proof is provided in the given page. </p>

</div>
</div>
<a id="acaffd49ffe08709f88da8eb947d1912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaffd49ffe08709f88da8eb947d1912f">&#9670;&nbsp;</a></span>has_self_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.has_self_loop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if graph has a self loop. </p>
<p>We check whether the incident vertices of an edge is same. </p>

</div>
</div>
<a id="a870136de71e0909de47bf1ecad90a912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870136de71e0909de47bf1ecad90a912">&#9670;&nbsp;</a></span>incoming_edges_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.incoming_edges_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain incoming edges of a given graph </p>
<p>Incoming edges are defined as edges that end with the given node. We only check for the position and do not consider the type of the edge For its use case see </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a8c19d8a8716b563f8f6579c3678ac379" title="obtain the outgoing edge set of a given node.">outgoing_edges_of()</a> <div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;g1&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([e1, e2]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; edges = graph.incoming_edges_of(n2)</div>
<div class="line">&gt;&gt;&gt; edges == set([e1])</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8373887504460cfe5ffa3bcfef11ee78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8373887504460cfe5ffa3bcfef11ee78">&#9670;&nbsp;</a></span>is_adjacent_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_adjacent_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two edges are adjacent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>an edge </td></tr>
    <tr><td class="paramname">e2</td><td>an edge</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.is_adjacent_of(e2, e3)</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="../../dd/d00/classgmodels_1_1gtypes_1_1digraph_1_1DiGraph.html#a06c7ada3ceec60ef04a42b8f6c73dd6e">gmodels.gtypes.digraph.DiGraph</a>.</p>

</div>
</div>
<a id="a8626da05db0727085154c07ab16a913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8626da05db0727085154c07ab16a913c">&#9670;&nbsp;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if graph is connected If a graph has a single component, then we assume that it is connected graph. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.is_connected()</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a41d8b99fc125cad2935bb3d1723a1de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d8b99fc125cad2935bb3d1723a1de0">&#9670;&nbsp;</a></span>is_homomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_homomorphism </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] &#160;</td>
          <td class="paramname"><em>phi_map</em> = <code>lambda&#160;x:&#160;x</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] &#160;</td>
          <td class="paramname"><em>psi_map</em> = <code>lambda&#160;x:&#160;x</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a function is a homomorphism on the given graph. </p>
<dl class="section warning"><dt>Warning</dt><dd>Absolutely untested function that tries to follow the definition given in Diestel 2017, p. 3. Basically if a function transforms vertex set of graph but conserve adjacency properties of the graph, it is a homomorphism. </dd></dl>

</div>
</div>
<a id="a925bcc74851c9a900383332a86e9cb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925bcc74851c9a900383332a86e9cb5f">&#9670;&nbsp;</a></span>is_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_in </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]&#160;</td>
          <td class="paramname"><em>ne</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if given edge or node is in graph </p>
<p>We check if given graph object is in the graph. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">TypeError</td><td>if the argument is not a node or an edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbd2985d817ab00400503592f373729c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd2985d817ab00400503592f373729c">&#9670;&nbsp;</a></span>is_neighbour_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_neighbour_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if two nodes are neighbours We define the condition of neighborhood as having a common edge, not being the same </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.is_neighbour_of(n2, n3)</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; graph_2.is_neighbour_of(n2, n2)</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">False</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a16c90f0b9ca76018de496f31f05ca67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c90f0b9ca76018de496f31f05ca67a">&#9670;&nbsp;</a></span>is_node_incident()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_node_incident </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a node is incident of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node We check if this node is an endvertex of the edge. </td></tr>
    <tr><td class="paramname">e</td><td>The queried edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5480b99977e709c077ee2fb49a004d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5480b99977e709c077ee2fb49a004d9b">&#9670;&nbsp;</a></span>is_node_independent_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_node_independent_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if two nodes are independent We consider two nodes independent if they are not the same, and they are not neighbours. </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.is_node_independent_of(n1, n3)</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05ca0965a51bd7e57467f990f8c3c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ca0965a51bd7e57467f990f8c3c394">&#9670;&nbsp;</a></span>is_related_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.is_related_to </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool]&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] &#160;</td>
          <td class="paramname"><em>es</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function for applying proximity conditions on a node pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first node subject to proximity condition </td></tr>
    <tr><td class="paramname">n2</td><td>second node subject to proximity condition </td></tr>
    <tr><td class="paramname">condition</td><td>proximity condition in the form of a callable. </td></tr>
    <tr><td class="paramname">es</td><td>edge set. We query the proximity condition in this set if it is specified</td></tr>
  </table>
  </dd>
</dl>
<p>We check whether a proximity condition is valid for given two nodes. </p>

</div>
</div>
<a id="a2c9948757fcbea8280d1bc1a4744e12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9948757fcbea8280d1bc1a4744e12d">&#9670;&nbsp;</a></span>is_stable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_stable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if given node set is stable </p>
<p>We ensure that no nodes in the given node set is a neighbour of one another as per the definition of Diestel 2017, p. 3.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if argument node set is not a subset of vertices of the graph <div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n5 = Node(<span class="stringliteral">&quot;n5&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4, n5]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.is_stable(set([n1, n3, n5]))</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc1aa3ff68d6a096dfb3e6ac3efac98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc1aa3ff68d6a096dfb3e6ac3efac98">&#9670;&nbsp;</a></span>is_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if graph instance is a tree. </p>
<p>This interpretation comes from Diestel 2017, p. 14 - 15. </p>

</div>
</div>
<a id="af0534a9c6c82464cc40a89608398a921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0534a9c6c82464cc40a89608398a921">&#9670;&nbsp;</a></span>is_trivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool gmodels.gtypes.graph.Graph.is_trivial </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if graph is trivial. </p>
<p>This triviality condition is taken from Diestel 2017, p. 2 </p>

</div>
</div>
<a id="a091c1c97613023c73a8e952a34a36dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091c1c97613023c73a8e952a34a36dba">&#9670;&nbsp;</a></span>mk_gdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.mk_gdata </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create edge list representation of graph. </p>
<p>For each node we register the edges. </p>

</div>
</div>
<a id="af5e394b4d834a0b4d6cc3fbd193a2eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e394b4d834a0b4d6cc3fbd193a2eff">&#9670;&nbsp;</a></span>mk_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.mk_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]]&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]&#160;</td>
          <td class="paramname"><em>es</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain all nodes in a single set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>set of nodes </td></tr>
    <tr><td class="paramname">es</td><td>set of edges</td></tr>
  </table>
  </dd>
</dl>
<p>We assume that node set and edge set might contain different nodes, that is \( V[G] = V[ns] \cup V[es] \) We combine nodes given in both sets to create a final set of nodes for the graph </p>

</div>
</div>
<a id="a4b90352b4987f8f5dd60185eae65be35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b90352b4987f8f5dd60185eae65be35">&#9670;&nbsp;</a></span>nb_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.nb_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the number of connected components in the given graph. </p>
<p>This number makes more sense in the case of undirected graphs as our algorithm is adapted for that case. It is computed as we are traversing the graph in <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0d0e8d39b5c3e805ff0a8f935963c95a" title="adapted for cycle detection dfs recursive forest from Erciyes 2018, Guide Graph .....">dfs_forest()</a> </p>

</div>
</div>
<a id="ab8ad6e200e8efac7a5d420e14b6952a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ad6e200e8efac7a5d420e14b6952a9">&#9670;&nbsp;</a></span>nb_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.nb_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain number of edges in the graph It corresponds to \( ||G|| \). </p>
<p>This interpretation is taken from Diestel 2017, p. 2. </p>

</div>
</div>
<a id="afd022b8f1fb077dbc7b7dc9dc6974162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd022b8f1fb077dbc7b7dc9dc6974162">&#9670;&nbsp;</a></span>nb_neighbours_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.nb_neighbours_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain number of neighbours of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node whose neighbour set we are interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#aa7931cbb1cd0bc28a03ef114c3efbc9d" title="obtain neighbour set of a given node.">Graph.neighbours_of</a></dd></dl>
<p>Number of nodes in the neighbour set of n.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2.nb_neighbours_of(n2)</div>
<div class="line">&gt;&gt;&gt; 2</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa7931cbb1cd0bc28a03ef114c3efbc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7931cbb1cd0bc28a03ef114c3efbc9d">&#9670;&nbsp;</a></span>neighbours_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] gmodels.gtypes.graph.Graph.neighbours_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain neighbour set of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>the node whose neighbour set we are searching for</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if node is not inside the graph</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e3 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e3&quot;</span>, start_node=n3, end_node=n4, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph_2 = Graph(</div>
<div class="line">&gt;&gt;&gt;   <span class="stringliteral">&quot;g2&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;   data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([e1, e2, e3]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; neighbours = graph_2.neighbours_of(n2)</div>
<div class="line">&gt;&gt;&gt; [n.id() <span class="keywordflow">for</span> n <span class="keywordflow">in</span> neighbours]</div>
<div class="line">&gt;&gt;&gt; [<span class="stringliteral">&quot;n1&quot;</span>, <span class="stringliteral">&quot;n3&quot;</span>]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1c7ac2968860a4d55c0f45f328dd43ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ac2968860a4d55c0f45f328dd43ed">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the number of vertices in the graph. </p>
<p>It corresponds to \( |G| \). This interpretation of order is taken from Diestel 2017, p. 2. </p>

</div>
</div>
<a id="a8c19d8a8716b563f8f6579c3678ac379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c19d8a8716b563f8f6579c3678ac379">&#9670;&nbsp;</a></span>outgoing_edges_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>] gmodels.gtypes.graph.Graph.outgoing_edges_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain the outgoing edge set of a given node. </p>
<p>Outgoing edge set means all edges that start with the given node and end in another node. This information is mostly trivial for undirected graphs but becomes important for distinguishing parents from children in directed graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node whose adjacent edges we are interested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge set of node.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if node is not in graph we raise a value error <div class="fragment"><div class="line">&gt;&gt;&gt; n1 = Node(<span class="stringliteral">&quot;n1&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n2 = Node(<span class="stringliteral">&quot;n2&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n3 = Node(<span class="stringliteral">&quot;n3&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; n4 = Node(<span class="stringliteral">&quot;n4&quot;</span>, {})</div>
<div class="line">&gt;&gt;&gt; e1 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e1&quot;</span>, start_node=n1, end_node=n2, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; e2 = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;e2&quot;</span>, start_node=n2, end_node=n3, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; graph = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;g1&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;     nodes=set([n1, n2, n3, n4]),</div>
<div class="line">&gt;&gt;&gt;     edges=set([e1, e2]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; edges = graph.outgoing_edges_of(n2)</div>
<div class="line">&gt;&gt;&gt; edges == set([e2])</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2857eff8ce47bd5c5b3326ee67806d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2857eff8ce47bd5c5b3326ee67806d1">&#9670;&nbsp;</a></span>set_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Optional[Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool]] gmodels.gtypes.graph.Graph.set_op </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a>]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>]]], Union[Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>], bool]]&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic set operation for graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the hooked object to operation. We deduce its corresponding argument from its type. </td></tr>
    <tr><td class="paramname">op</td><td>operation that is going to be applied to obj and its corresponding object.</td></tr>
  </table>
  </dd>
</dl>
<p>The idea is to give a single interface for generic set operation functions. For example if object is a set of nodes we provide the target for the operation as the nodes of this graph, if it is an edge we provide a set of edges of this graph </p>

</div>
</div>
<a id="afe28686daac19f3ac7e66d20ec36f1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe28686daac19f3ac7e66d20ec36f1ac">&#9670;&nbsp;</a></span>shortest_cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the shortest possible cycle length for graph instance The interpretation comes from Diestel 2017, p. </p>
<p>8. </p>

</div>
</div>
<a id="a38ed19ae0672276d1fba1fddda4f3273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ed19ae0672276d1fba1fddda4f3273">&#9670;&nbsp;</a></span>shortest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int gmodels.gtypes.graph.Graph.shortest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the shortest possible path length for graph instance. </p>
<p>This interpretation is taken from Diestel 2017, p. 8. The proof is also given in the corresponding page. </p>

</div>
</div>
<a id="aea310a1d18601f7a1653af67de5b2fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea310a1d18601f7a1653af67de5b2fd3">&#9670;&nbsp;</a></span>subtract_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../dc/de3/classgmodels_1_1gtypes_1_1graphobj_1_1GraphObject.html">GraphObject</a> gmodels.gtypes.graph.Graph.subtract_edge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new graph by subtracting edge from edge set of graph instance </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#af239077400d675d6d144b9b53795104d" title="create a new graph by subtracting the argument node.">subtract_node()</a> as well </dd></dl>

</div>
</div>
<a id="a995842afcea5e62b7fb96394a4b4c606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995842afcea5e62b7fb96394a4b4c606">&#9670;&nbsp;</a></span>to_adjmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[Tuple[str, str], int] gmodels.gtypes.graph.Graph.to_adjmat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vtype</em> = <code>int</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform adjacency list to adjacency matrix representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtype</td><td>the cast type for the entry of adjacency matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacency matrix whose keys are identifiers of nodes and values are flags whether there is an edge between them.</dd></dl>
<div class="fragment"><div class="line">&gt;&gt;&gt; a = Node(<span class="stringliteral">&quot;a&quot;</span>, {})  <span class="comment"># b</span></div>
<div class="line">&gt;&gt;&gt; b = Node(<span class="stringliteral">&quot;b&quot;</span>, {})  <span class="comment"># c</span></div>
<div class="line">&gt;&gt;&gt; f = Node(<span class="stringliteral">&quot;f&quot;</span>, {})  <span class="comment"># d</span></div>
<div class="line">&gt;&gt;&gt; e = Node(<span class="stringliteral">&quot;e&quot;</span>, {})  <span class="comment"># e</span></div>
<div class="line">&gt;&gt;&gt; ae = Edge(</div>
<div class="line">&gt;&gt;&gt;    <span class="stringliteral">&quot;ae&quot;</span>, start_node=a, end_node=e, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; af = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;af&quot;</span>, start_node=a, end_node=f, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; ef = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;ef&quot;</span>, start_node=e, end_node=f, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; ugraph1 = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;graph&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([a, b, e, f]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([ae, af, ef]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; mat = ugraph1.to_adjmat(vtype=bool)</div>
<div class="line">&gt;&gt;&gt; mat == {</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">False</span></div>
<div class="line">&gt;&gt;&gt; }</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad0d0fc95e76ba3e1684901d07da832be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d0fc95e76ba3e1684901d07da832be">&#9670;&nbsp;</a></span>transitive_closure_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[Tuple[str, str], bool] gmodels.gtypes.graph.Graph.transitive_closure_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain transitive closure matrix of a given graph. </p>
<p>Transitive closure is defined by Joyner, et. al. as:</p>
<ul>
<li>Consider a digraph \(G = (V, E)\) of order \(n = |V |\). The transitive closure of G is defined as the digraph \(G^{} = (V, E^{}) \) having the same vertex set as G. However, the edge set \(E^{}\) of \(G^{}\) consists of all edges uv such that there is a u-v path in G and \(uv \not \in E\). The transitive closure \(G^{*}\) answers an important question about G: If u and v are two distinct vertices of G, are they connected by a path with length  1?</li>
</ul>
<p>Variant of the Floyd-Roy-Warshall algorithm taken from Joyner, Phillips, Nguyen, Algorithmic <a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html" title="Simple finite graph  where  is the vertex set and  is the edge set.">Graph</a> Theory, 2013, p.134</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>we raise a value error if the graph has a self loop.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">&gt;&gt;&gt; a = Node(<span class="stringliteral">&quot;a&quot;</span>, {})  <span class="comment"># b</span></div>
<div class="line">&gt;&gt;&gt; b = Node(<span class="stringliteral">&quot;b&quot;</span>, {})  <span class="comment"># c</span></div>
<div class="line">&gt;&gt;&gt; f = Node(<span class="stringliteral">&quot;f&quot;</span>, {})  <span class="comment"># d</span></div>
<div class="line">&gt;&gt;&gt; e = Node(<span class="stringliteral">&quot;e&quot;</span>, {})  <span class="comment"># e</span></div>
<div class="line">&gt;&gt;&gt; ae = Edge(</div>
<div class="line">&gt;&gt;&gt;    <span class="stringliteral">&quot;ae&quot;</span>, start_node=a, end_node=e, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; af = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;af&quot;</span>, start_node=a, end_node=f, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; ef = Edge(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;ef&quot;</span>, start_node=e, end_node=f, edge_type=EdgeType.UNDIRECTED</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; ugraph1 = Graph(</div>
<div class="line">&gt;&gt;&gt;     <span class="stringliteral">&quot;graph&quot;</span>,</div>
<div class="line">&gt;&gt;&gt;     data={<span class="stringliteral">&quot;my&quot;</span>: <span class="stringliteral">&quot;graph&quot;</span>, <span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;is&quot;</span>, <span class="stringliteral">&quot;very&quot;</span>: <span class="stringliteral">&quot;awesome&quot;</span>},</div>
<div class="line">&gt;&gt;&gt;   nodes=set([a, b, e, f]),</div>
<div class="line">&gt;&gt;&gt;   edges=set([ae, af, ef]),</div>
<div class="line">&gt;&gt;&gt; )</div>
<div class="line">&gt;&gt;&gt; mat == {</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">False</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>): <span class="keyword">True</span>,</div>
<div class="line">&gt;&gt;&gt;     (<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>): <span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt;   }</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">True</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa3a7bfb128185fbd175af7b2b96ca1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a7bfb128185fbd175af7b2b96ca1dc">&#9670;&nbsp;</a></span>V()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] gmodels.gtypes.graph.Graph.V </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain vertices of the graph. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if node set is empty for the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28faa97a14c1b297054dff59aea4be03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28faa97a14c1b297054dff59aea4be03">&#9670;&nbsp;</a></span>vertex_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a> gmodels.gtypes.graph.Graph.vertex_by_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>node_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain vertex by using its identifier </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if the node is not in graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6626c5feebb7366b90776e47effef10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6626c5feebb7366b90776e47effef10">&#9670;&nbsp;</a></span>vertices_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>, <a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>] gmodels.gtypes.graph.Graph.vertices_of </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d93/classgmodels_1_1gtypes_1_1edge_1_1Edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain all vertices associated with an edge. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ValueError</td><td>if edge is not inside the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8ce9cb8cf0951f366f6a012c8c859a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ce9cb8cf0951f366f6a012c8c859a0">&#9670;&nbsp;</a></span>visit_graph_dfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gmodels.gtypes.graph.Graph.visit_graph_dfs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>], Set[<a class="el" href="../../db/d8b/classgmodels_1_1gtypes_1_1node_1_1Node.html">Node</a>]]&#160;</td>
          <td class="paramname"><em>edge_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>check_cycle</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interior visit function for depth first enumeration of graph instance. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d2/dfc/classgmodels_1_1gtypes_1_1graph_1_1Graph.html#a0d0e8d39b5c3e805ff0a8f935963c95a" title="adapted for cycle detection dfs recursive forest from Erciyes 2018, Guide Graph .....">dfs_forest()</a> method for more information on parameters. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>graphical-models/gmodels/gtypes/<a class="el" href="../../d5/d1b/graph_8py.html">graph.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
